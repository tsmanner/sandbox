#ifndef MultiRange_h
#define MultiRange_h

#include <chrono>
#include <exception>
#include <ostream>
#include <random>
#include <set>
#include <utility>

#include "Range.h"


struct MultiRangeDrawOutOfRangeException : public std::exception {
  virtual const char* what() const throw() {
    return "MultiRange draw index out of range!";
  }
};


class MultiRange {
public:
  static std::default_random_engine generator;
  using RangeSet = std::set<Range, Range::Compare>;

  RangeSet& getRanges() { return mRanges; }
  const RangeSet& getRanges() const { return mRanges; }

  template <typename ValueType>
  bool covers(const ValueType& inValue) {
    for (auto range : mRanges) {
      if (range.covers(inValue)) {
        return true;
      }
    }
    return false;
  }

  void addRange(Range r) {
    mRanges.insert(r);
    optimize();
  }

  void optimize() {
    mRanges = disjunction(mRanges);
  }

  // Creates a new optimized set of ranges from the disjunction
  // of all overlapping or adjacent Range instances in mRanges
  //
  // Start at the beginning of the set (with the lowest lower bound)
  // and scan, iteratively building the disjunction of each overlapping
  // Range.  Once a non-overlapping range is encountered, insert the
  // new one into the optimized set and select the non-overlapping range
  // as the new base range.  Repeat until done.
  static RangeSet disjunction(const RangeSet& inRangeSet) {
    RangeSet disjunctionRangeSet;
    auto iter = inRangeSet.begin();
    auto disjunctionRange = *iter;

    for (; iter != inRangeSet.end(); ++iter) {
      if (
        Range::overlaps(disjunctionRange, *iter)
        or
        Range::adjacent(disjunctionRange, *iter)
      ) {
        disjunctionRange = Range::disjunction(disjunctionRange, *iter);
      }
      else {
        disjunctionRangeSet.insert(disjunctionRange);
        disjunctionRange = *iter;
      }
    }
    disjunctionRangeSet.insert(disjunctionRange);
    return disjunctionRangeSet;
  }

  // Creates a new optimized set of ranges from the conjunction
  // of all Range instances in mRanges
  //
  // Start at the beginning of the set (with the lowest lower bound)
  // and scan, iteratively building the conjunction of each overlapping
  // Range.  If a non-overlapping range is encountered, the conjunction
  // of all Ranges is empty, so immediately return an empty set.
  static RangeSet conjunction(const RangeSet& inRangeSet) {
    RangeSet conjunctionRangeSet;
    auto iter = inRangeSet.begin();
    auto conjunctionRange = *iter;

    for (; iter != inRangeSet.end(); ++iter) {
      if (Range::overlaps(conjunctionRange, *iter)) {
        conjunctionRange = Range::conjunction(conjunctionRange, *iter);
      }
      else {
        return RangeSet();
      }
    }
    conjunctionRangeSet.insert(conjunctionRange);
    return conjunctionRangeSet;
  }

  // Disjunction of two MultiRanges is the disjunction
  // of all ranges contained in both.  Create the set
  // all ranges, and then optimize it.
  static MultiRange disjunction(const MultiRange& lhs, const MultiRange& rhs) {
    auto disjunctionMultiRange = MultiRange();
    disjunctionMultiRange.mRanges.insert(lhs.mRanges.begin(), lhs.mRanges.end());
    disjunctionMultiRange.mRanges.insert(rhs.mRanges.begin(), rhs.mRanges.end());
    disjunctionMultiRange.optimize();
    return disjunctionMultiRange;
  }

  // Conjunction of two MultiRanges is the conjunction
  // of all pairs of overlapping ranges, one from each
  // MultiRange.  The set of all overlapping ranges
  // can be generated by iterating over all ranges in
  // the lhs and for each range in the rhs that overlaps,
  // add the conjunction of the ranges.
  static MultiRange conjunction(const MultiRange& lhs, const MultiRange& rhs) {
    auto conjunctionMultiRange = MultiRange();
    for (auto lhsRange : lhs.mRanges) {
      for (auto rhsRange : rhs.mRanges) {
        if (Range::overlaps(lhsRange, rhsRange)) {
          conjunctionMultiRange.addRange(Range::conjunction(lhsRange, rhsRange));
        }
      }
    }
    return conjunctionMultiRange;
  }

  friend std::ostream& operator<<(std::ostream& os, MultiRange mr) {
    os << "(";
    for (auto iter = mr.mRanges.begin(); iter != mr.mRanges.end(); ++iter) {
      if (iter != mr.mRanges.begin()) os << ", ";
      os << *iter;
    }
    os << ")";
    return os;
  }

  size_t size() {
    size_t value = 0;
    for (auto r : getRanges()) {
      value += r.size();
    }
    return value;
  }

  int draw() {
    std::uniform_int_distribution<size_t> distribution(0, size()-1);
    size_t element_idx = distribution(MultiRange::generator);
    for (auto r : getRanges()) {
      if (element_idx < r.size()) {
        return r.getLowerBound().getValue() + int(element_idx);
      }
      element_idx -= r.size();
    }
    throw MultiRangeDrawOutOfRangeException();
  }

private:
  RangeSet mRanges;

};


std::default_random_engine MultiRange::generator = std::default_random_engine(std::chrono::system_clock::now().time_since_epoch().count());

#endif
